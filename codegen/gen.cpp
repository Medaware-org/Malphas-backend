/**
 * This script's purpose is to generate DAOs from an already existing database.
 * It accomplishes this by connecting to said DB, querying the tables of the 'public' schema,
 * and generating structs as well as utility functions for each table after performing
 * SQL to C++ type mappings. This script is meant to run >after< the database has been migrated!
 **/

#include <string>
#include <iostream>
#include <format>
#include <cfg/Config.hpp>
#include <libpq-fe.h>

PGconn *connect_db(std::string user, std::string password, std::string db, std::string host, int port)
{
        std::string conn_str = std::format("user={} password={} dbname={} port={} host={}", user, password, db, port,
                                           host);

        PGconn *conn = PQconnectdb(conn_str.c_str());

        if (PQstatus(conn) != CONNECTION_OK) {
                printf("ERR: Could not connect to the database.\n");
                PQfinish(conn);
                return nullptr;
        }

        return conn;
}

#define MAP(src, dst) if (org == src) return dst;

/*
 * This function maps the type from PostgreSQL relations to C++ types
 */
std::string map_types(std::string &org)
{
        MAP("text", "std::string")
        MAP("uuid", "std::string")

        return "std::any";
}

#undef MAP

int serialise_table(PGconn *conn, std::string &table)
{
        std::string query = std::format("select * from information_schema.columns where table_name = '{}'", table);
        PGresult *res = PQexec(conn, query.c_str());

        if (PQresultStatus(res) != PGRES_TUPLES_OK) {
                std::cerr << "ERR: Could not query fields of table '" << table << "'" << std::endl;
                PQclear(res);
                return -1;
        }

        int nTuples = PQntuples(res);

        // Emit the struct
        std::cout << "struct " << table << " {" << std::endl;
        for (int i = 0; i < nTuples; i++) {
                std::string column = PQgetvalue(res, i, 3);
                std::string type = PQgetvalue(res, i, 7);
                std::cout << "\t" << map_types(type) << " " << column << ";" << std::endl;
        }
        std::cout << "};\n\n";

        // Emit insert function
        std::cout << "bool " << table << "_insert(Database &db, ";
        for (int i = 0; i < nTuples; i++) {
                std::string column = PQgetvalue(res, i, 3);
                std::string type = PQgetvalue(res, i, 7);
                std::cout << map_types(type) << " " << column;
                std::cout << ((i + 1 < nTuples) ? ", " : ") {\n");
        }

        std::cout << "\tstd::string query = \"INSERT INTO " << table << "(";
        for (int i = 0; i < nTuples; i++) {
                std::string column = PQgetvalue(res, i, 3);
                std::cout << column;
                std::cout << ((i + 1 < nTuples) ? ", " : ") VALUES (");
        }

        for (int i = 0; i < nTuples; i++) {
                std::string column = PQgetvalue(res, i, 3);
                std::string type = PQgetvalue(res, i, 7);
                int quotes = 0;

                if (type == "text" || type.find("varchar") != std::string::npos)
                        quotes = 1;

                if (quotes)
                        std::cout << "\\\"";

                std::cout << "\" + " << column << " + \"";

                if (quotes)
                        std::cout << "\\\"";

                std::cout << ((i + 1 < nTuples) ? ", " : ")\";\n");
        }

        std::cout << "\treturn dao_query(db, query, PGRES_COMMAND_OK);" << std::endl;
        std::cout << "}\n\n";

        PQclear(res);

        return 0;
}

int generate_tables(PGconn *conn)
{
        const std::string query = "select * from information_schema.tables where table_schema = 'public'";
        PGresult *res = PQexec(conn, query.c_str());

        if (PQresultStatus(res) != PGRES_TUPLES_OK) {
                std::cerr << "ERR: Could not query tables." << std::endl;
                PQclear(res);
                return -1;
        }

        int nTuples = PQntuples(res);
        for (int i = 0; i < nTuples; i++) {
                std::string table = PQgetvalue(res, i, 2);

                if (table == "db_migration")
                        continue;

                if (serialise_table(conn, table) < 0)
                        return -1;
        }
        PQclear(res);
        return 0;
}

void gen_preamble()
{
        std::cout << "/**\n"
                     " * This file was generated by the Malphas DAO generator\n"
                     " */\n"
                     "\n"
                     "#pragma once\n"
                     "\n"
                     "#include <string>\n"
                     "#include <any>\n"
                     "#include <libpq-fe.h>\n"
                     "#include <Database.hpp>\n\n"
                     "static bool dao_query(Database &db, std::string query, ExecStatusType assert_status)\n"
                     "{\n"
                     "\tExecStatusType status;\n"
                     "        PGresult *res = db.query(query, &status);\n"
                     "\tbool ok = true;\n"
                     "\tif (status != assert_status)\n"
                     "\t\tok = false;\n"
                     "\tPQclear(res);\n"
                     "\treturn ok;\n"
                     "}\n\n";
}

int main()
{
        db_config cfg;
        if (!parse_db_config(&cfg))
                return 1;

        PGconn *conn = connect_db(cfg.user, cfg.password, cfg.db, cfg.host, cfg.port);
        if (!conn)
                return 1;

        gen_preamble();

        int status = 0;

        if (generate_tables(conn) < 0)
                status = -1;

        PQfinish(conn);

        return status;
}