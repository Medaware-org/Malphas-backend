/**
 * This script's purpose is to generate DAOs from an already existing database.
 * It accomplishes this by connecting to said DB, querying the tables of the 'public' schema,
 * and generating structs as well as utility functions for each table after performing
 * SQL to C++ type mappings. This script is meant to run >after< the database has been migrated!
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libpq-fe.h>

PGconn *connect_db(const char *user, const char *password, const char *db, const char *host, int port)
{
        const char *conn_str_fmt = "user=%s password=%s dbname=%s port=%d host=%s";
        unsigned int fmt_len = strlen(conn_str_fmt);
        unsigned int param_len = strlen(user) + strlen(password) + strlen(db) + strlen(host) + 10;
        char *buffer = (char *) calloc(fmt_len + param_len, sizeof(char));
        sprintf(buffer, conn_str_fmt, user, password, db, port, host);

        PGconn *conn = PQconnectdb(buffer);
        free(buffer);

        if (PQstatus(conn) != CONNECTION_OK) {
                printf("ERR: Could not connect to the database.\n");
                PQfinish(conn);
                return NULL;
        }

        return conn;
}

#define MAP(src, dst) if (strcmp(org, src) == 0) return dst;

const char *map_types(char *org)
{
        MAP("text", "std::string")
        MAP("uuid", "std::string")

        return "std::any";
}

#undef MAP

int serialise_table(PGconn *conn, char *table)
{
        const char *query_fmt = "select * from information_schema.columns where table_name = '%s'";
        char *query = (char *) calloc(strlen(query_fmt) + strlen(table) + 10, sizeof(char));
        sprintf(query, query_fmt, table);
        PGresult *res = PQexec(conn, query);
        free(query);

        if (PQresultStatus(res) != PGRES_TUPLES_OK) {
                printf("ERR: Could not query fields of table '%s'\n", table);
                PQclear(res);
                return -1;
        }

        int nTuples = PQntuples(res);

        // Emit the struct
        printf("struct %s {\n", table);
        for (int i = 0; i < nTuples; i++) {
                char *column = PQgetvalue(res, i, 3);
                char *type = PQgetvalue(res, i, 7);
                printf("\t%s %s;\n", map_types(type), column);
        }
        printf("};\n\n");

        // Emit insert function
        printf("bool %s_insert(Database &db, ", table);
        for (int i = 0; i < nTuples; i++) {
                char *column = PQgetvalue(res, i, 3);
                char *type = PQgetvalue(res, i, 7);
                printf("%s %s", map_types(type), column);
                if (i + 1 < nTuples)
                        printf(", ");
                else
                        printf(") {\n");
        }
        printf("\tstd::string query = \"INSERT INTO %s (", table);
        for (int i = 0; i < nTuples; i++) {
                char *column = PQgetvalue(res, i, 3);
                printf("%s", column);
                if (i + 1 < nTuples)
                        printf(", ");
                else
                        printf(") VALUES (");
        }
        for (int i = 0; i < nTuples; i++) {
                char *column = PQgetvalue(res, i, 3);
                char *type = PQgetvalue(res, i, 7);
                int quotes = 0;

                if (strcmp(type, "text") == 0 || strstr(type, "varchar") != NULL)
                        quotes = 1;

                if (quotes)
                        printf("\\\"");

                printf("\" + %s + \"", column);

                if (quotes)
                        printf("\\\"");
                if (i + 1 < nTuples)
                        printf(", ");
                else
                        printf(")\";\n");
        }
        printf("\treturn dao_query(db, query, PGRES_COMMAND_OK);\n");
        printf("}\n\n");

        PQclear(res);

        return 0;
}

int generate_tables(PGconn *conn)
{
        const char *query = "select * from information_schema.tables where table_schema = 'public'";
        PGresult *res = PQexec(conn, query);
        if (PQresultStatus(res) != PGRES_TUPLES_OK) {
                printf("ERR: Could not query tables.\n");
                PQclear(res);
                return -1;
        }
        int nTuples = PQntuples(res);
        for (int i = 0; i < nTuples; i++) {
                char *table_name = PQgetvalue(res, i, 2);

                if (strcmp(table_name, "db_migration") == 0)
                        continue;

                if (serialise_table(conn, table_name) < 0)
                        return -1;
        }
        PQclear(res);
        return 0;
}

void gen_preamble()
{
        printf("/**\n"
               " * This file was generated by the Malphas DAO generator\n"
               " */\n"
               "\n"
               "#pragma once\n"
               "\n"
               "#include <string>\n"
               "#include <any>\n"
               "#include <libpq-fe.h>\n"
               "#include <Database.hpp>\n\n"
               "static bool dao_query(Database &db, std::string query, ExecStatusType assert_status)\n"
               "{\n"
               "\tExecStatusType status;\n"
               "        PGresult *res = db.query(query, &status);\n"
               "\tbool ok = true;\n"
               "\tif (status != assert_status)\n"
               "\t\tok = false;\n"
               "\tPQclear(res);\n"
               "\treturn ok;\n"
               "}\n\n");
}

int main()
{
        PGconn *conn = connect_db("malphas", "root", "malphas", "localhost", 5432);
        if (!conn)
                return 1;

        gen_preamble();

        int status = 0;

        if (generate_tables(conn) < 0)
                status = -1;

        PQfinish(conn);

        return status;
}